# 📄 기술 구현 및 의사결정 보고서

이 문서는 프로젝트 개발 과정에서 발생한 주요 기술적 이슈와 그에 대한 해결 방법(동시성 제어, 파일 스토리지)을 상세히 기술합니다. 발표 자료나 기술 면접 준비 시 참고하시기 바랍니다.

---

## 1. 동시성 문제 해결 (Concurrency Control)

### 🚨 문제 상황 (Problem)
'좋아요(Like)' 기능과 같이 여러 사용자가 동시에 접근하여 데이터를 수정할 수 있는 기능에서는 **경쟁 상태(Race Condition)**가 발생할 수 있습니다.
*   **예시**: 좋아요 수가 100개일 때, 사용자 A와 B가 동시에 좋아요를 누름.
*   **기대 결과**: 102 (A: 100 -> 101, B: 101 -> 102)
*   **실제 오류**: 101 (두 트랜잭션 모두 초기값 100을 읽어서 101로 저장해버림, **갱신 손실(Lost Update) 발생**)

### ✅ 해결 방법: 낙관적 락 (Optimistic Locking)
우리 프로젝트는 데이터베이스의 **낙관적 락(Optimistic Locking)**을 사용하여 이 문제를 해결했습니다.

#### 1) 구현 기술
*   **JPA `@Version`**: `Photo` 엔티티에 `version` 필드를 추가하고 `@Version` 어노테이션을 적용했습니다.
*   **동작 원리**:
    1.  데이터를 읽을 때 현재 버전을 함께 조회합니다 (예: v1).
    2.  수정 후 저장(UPDATE)할 때 `WHERE version = 1` 조건을 붙여서 쿼리를 날립니다.
    3.  만약 그 사이에 다른 트랜잭션이 수정해서 버전이 v2로 바뀌었다면, 조건이 맞지 않아 수정 쿼리가 실패합니다(0 row updated).
    4.  JPA는 이를 감지하고 `ObjectOptimisticLockingFailureException` 예외를 발생시킵니다.

#### 2) 코드 구현 상세 (`PhotoController.java`)
```java
try {
    // 좋아요 수 증가
    photo.setLikeCount(photo.getLikeCount() + 1);
    
    // 저장 시도 (버전 체크 수행됨)
    photoRepository.save(photo); 

    // 좋아요 이력 저장
    PhotoLike like = new PhotoLike(user, photo);
    photoLikeRepository.save(like);

} catch (ObjectOptimisticLockingFailureException e) {
    // 충돌 발생 시 예외 처리
    return ResponseEntity.status(409).body("Concurrency conflict! Please try again.");
}
```

#### 💡 의사결정 이유 (Why Optimistic Lock?)
*   **비관적 락(Pessimistic Lock)을 쓰지 않은 이유**: 비관적 락(DB 레벨에서 `SELECT for UPDATE`로 줄 세우기)은 데이터 무결성은 확실하지만, 트랜잭션 대기 시간이 길어져 **성능 저하(Deadlock 위험 등)**를 유발할 수 있습니다.
*   **낙관적 락 선택 이유**: SNS의 '좋아요' 기능은 금융 거래처럼 충돌이 치명적이거나 빈번하지 않습니다. 따라서 성능 손해를 최소화하면서 정합성을 지킬 수 있는 낙관적 락이 가장 효율적이라고 판단했습니다.

---

## 2. AWS S3 도입 (Cloud Storage)

### 🚨 문제 상황 (Problem)
초기 개발 단계에서 서버(로컬 디스크)에 이미지를 직접 저장할 경우 다음과 같은 문제가 발생했습니다.
1.  **확장성(Scalability) 부족**: 서버를 증설(Scale-out)할 때, A 서버에 저장된 이미지를 B 서버에서는 조회할 수 없습니다. (이미지 엑박 현상)
2.  **서버 부하**: 이미지 파일 업로드/다운로드 트래픽이 웹 서버 대역폭을 점유하여, 정작 중요한 API 처리 성능이 떨어질 수 있습니다.

### ✅ 해결 방법: AWS S3 (Simple Storage Service)
파일 저장소를 웹 서버와 분리하여 AWS의 객체 스토리지 서비스인 S3를 도입했습니다.

#### 1) 구현 기술
*   **Spring Cloud AWS (`S3Template`)**: AWS SDK를 직접 다루는 대신, Spring 친화적인 라이브러리를 사용하여 안정성과 생산성을 높였습니다.
*   **UUID 파일명 처리**:
    ```java
    // S3Service.java
    String fileName = bucketFolder + UUID.randomUUID() + "_" + file.getOriginalFilename();
    ```
    S3 버킷 내에서 파일명 중복으로 인한 덮어쓰기 사고를 방지하기 위해 파일명에 고유 식별자(UUID)를 부여했습니다.

### 💡 도입 이점 (Benefits)
1.  **Stateless(무상태) 아키텍처 구현**: 파일이 외부에 저장되므로 서버는 상태를 가지지 않게 되어, 언제든지 **서버를 종료하거나 수평 확장(Auto Scaling)하는 것이 가능**해졌습니다.
2.  **부하 분산**: 정적 리소스(이미지) 제공을 S3가 전담하므로 백엔드 서버의 리소스를 아낄 수 있습니다.
3.  **내구성 및 가용성**: AWS S3가 제공하는 높은 데이터 내구성을 통해 디스크 고장 등으로 인한 데이터 유실 위험을 원천 차단했습니다.

---

### 📝 요약 (발표용 멘트)
> "본 프로젝트는 **확장성 있는 아키텍처**를 위해 파일 저장소를 AWS S3로 분리하여 서버를 Stateless하게 설계하였으며, 데이터 수정 시 발생할 수 있는 동시성 이슈는 성능 저하를 최소화하는 **낙관적 락(Optimistic Lock)** 방식으로 해결하여 데이터 정합성을 보장했습니다."
