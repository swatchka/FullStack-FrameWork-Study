# 📄 기술 구현 및 의사결정 보고서

이 문서는 프로젝트 개발 과정에서 발생한 주요 기술적 이슈와 그에 대한 해결 방법(동시성 제어, 파일 스토리지)을 상세히 기술합니다. 발표 자료나 기술 면접 준비 시 참고하시기 바랍니다.

---

## 1. 동시성 문제 해결 (Concurrency Control)

### 🚨 문제 상황 (Problem)
'좋아요(Like)' 기능과 같이 여러 사용자가 동시에 접근하여 데이터를 수정할 수 있는 기능에서는 **경쟁 상태(Race Condition)**가 발생할 수 있습니다.
*   **예시**: 좋아요 수가 100개일 때, 사용자 A와 B가 동시에 좋아요를 누릅니다.
*   **기대 결과**: 102 (A: 100 -> 101, B: 101 -> 102)
*   **실제 오류**: 101 (두 트랜잭션 모두 초기값 100을 읽어서 101로 저장해버려 **갱신 손실(Lost Update)**이 발생합니다.)

### ✅ 해결 방법: 낙관적 락 (Optimistic Locking)
본 프로젝트는 데이터베이스의 **낙관적 락(Optimistic Locking)**을 사용하여 이 문제를 해결했습니다.

#### 1) 구현 기술
*   **JPA `@Version`**: `Photo` 엔티티에 `version` 필드를 추가하고 `@Version` 어노테이션을 적용했습니다.
*   **동작 원리**:
    1.  데이터를 읽을 때 현재 버전을 함께 조회합니다 (예: v1).
    2.  수정 후 저장(UPDATE)할 때 `WHERE version = 1` 조건을 붙여서 쿼리를 수행합니다.
    3.  만약 그 사이에 다른 트랜잭션이 수정해서 버전이 v2로 바뀌었다면, 조건이 불일치하여 수정 쿼리가 실패합니다(0 row updated).
    4.  JPA는 이를 감지하고 `ObjectOptimisticLockingFailureException` 예외를 발생시킵니다.

#### 2) 코드 구현 상세 (`PhotoController.java`)
```java
try {
    // 좋아요 수 증가
    photo.setLikeCount(photo.getLikeCount() + 1);
    
    // 저장 시도 (버전 체크 수행됨)
    photoRepository.save(photo); 

    // 좋아요 이력 저장
    PhotoLike like = new PhotoLike(user, photo);
    photoLikeRepository.save(like);

} catch (ObjectOptimisticLockingFailureException e) {
    // 충돌 발생 시 예외 처리
    return ResponseEntity.status(409).body("Concurrency conflict! Please try again.");
}
```

#### 💡 의사결정 이유 (Why Optimistic Lock?)
*   **비관적 락(Pessimistic Lock)을 쓰지 않은 이유**: 비관적 락(DB 레벨에서 `SELECT for UPDATE`로 줄 세우기)은 데이터 무결성은 확실하지만, 트랜잭션 대기 시간이 길어져 **성능 저하(Deadlock 위험 등)**를 유발할 수 있습니다.
*   **낙관적 락 선택 이유**: SNS의 '좋아요' 기능은 금융 거래처럼 충돌이 치명적이거나 빈번하지 않습니다. 따라서 성능 손해를 최소화하면서 정합성을 지킬 수 있는 낙관적 락이 가장 효율적이라고 판단했습니다.

---

## 2. AWS S3 도입 (Cloud Storage)

### 🚨 문제 상황 (Problem)
초기 개발 단계에서 서버(로컬 디스크)에 이미지를 직접 저장할 경우 다음과 같은 문제가 발생했습니다.
1.  **확장성(Scalability) 부족**: 서버를 증설(Scale-out)할 때, A 서버에 저장된 이미지를 B 서버에서는 조회할 수 없습니다. (이미지 엑박 현상)
2.  **서버 부하**: 이미지 파일 업로드/다운로드 트래픽이 웹 서버 대역폭을 점유하여, 정작 중요한 API 처리 성능이 저하될 수 있습니다.

### ✅ 해결 방법: AWS S3 (Simple Storage Service)
파일 저장소를 웹 서버와 분리하여 AWS의 객체 스토리지 서비스인 S3를 도입했습니다.

#### 1) 구현 기술
*   **Spring Cloud AWS (`S3Template`)**: AWS SDK를 직접 다루는 대신, Spring 친화적인 라이브러리를 사용하여 안정성과 생산성을 높였습니다.
*   **UUID 파일명 처리**:
    ```java
    // S3Service.java
    String fileName = bucketFolder + UUID.randomUUID() + "_" + file.getOriginalFilename();
    ```
    S3 버킷 내에서 파일명 중복으로 인한 덮어쓰기 사고를 방지하기 위해 파일명에 고유 식별자(UUID)를 부여했습니다.

### 💡 도입 이점 (Benefits)
1.  **Stateless(무상태) 아키텍처 구현**: 파일이 외부에 저장되므로 서버는 상태를 가지지 않게 되어, 언제든지 **서버를 종료하거나 수평 확장(Auto Scaling)하는 것이 가능**해졌습니다.
2.  **부하 분산**: 정적 리소스(이미지) 제공을 S3가 전담하므로 백엔드 서버의 리소스를 절약할 수 있습니다.
3.  **내구성 및 가용성**: AWS S3가 제공하는 높은 데이터 내구성을 통해 디스크 고장 등으로 인한 데이터 유실 위험을 원천 차단했습니다.

---

## 3. 정적 리소스 vs 동적 리소스 (심화 기술 분석)

### 📝 개념 정의
| 구분 | 정적 리소스 (Static Resources) | 동적 리소스 (Dynamic Resources) |
| :--- | :--- | :--- |
| **정의** | 서버가 추가 연산 없이 **있는 그대로(As-is)** 반환하는 파일 | 사용자 요청에 따라 **서버가 계산(Computing)하여 생성**하는 데이터 |
| **예시** | 이미지(JPG, PNG), CSS, JS(번들), 폰트, HTML | API JSON 응답, JSP/Thymeleaf 렌더링 결과, 검색 결과 |
| **처리 주체** | Web Server (Nginx, Apache) 또는 CDN | Application Server (Tomcat, Node.js) + Database |

### 🛠️ 기술적 구분 기준 (Technical Criteria)

#### 1) 멱등성 (Idempotency) 및 불변성 (Immutability)
*   **정적**: 항상 $f(x) = y$ 입니다. 같은 URL(`logo.png`)을 호출하면 100번 호출해도 100번 똑같은 바이너리 데이터가 반환됩니다. 내용은 배포 시점에 결정되며 실행 중(Runtime)에는 절대 변하지 않습니다.
*   **동적**: $f(x, t) = y$ 입니다. 같은 URL(`/api/user/me`)을 호출해도 시간(t), 로그인한 사용자(Session), DB 상태에 따라 결과가 매번 달라질 수 있습니다.

#### 2) 캐싱 전략 (HTTP Caching)
*   **정적**: 브라우저나 CDN이 적극적으로 캐싱합니다.
    *   응답 헤더 예시: `Cache-Control: max-age=31536000` (1년 동안 다시 요청하지 말 것)
*   **동적**: 캐싱을 하지 않거나 매우 짧게 설정합니다.
    *   응답 헤더 예시: `Cache-Control: no-cache, no-store` (데이터가 실시간으로 변하므로 저장하지 말 것)

#### 3) I/O 처리 방식 (Kernel Level)
*   **정적 (Zero Copy)**: 운영체제 레벨에서 `sendfile()` 시스템 콜을 사용하여, 디스크에서 읽은 데이터를 커널 공간(Kernel Space)에서 바로 네트워크 소켓으로 전송합니다. CPU가 데이터를 들여다보지 않으므로 매우 빠릅니다. (Nginx가 빠른 이유)
*   **동적**: 디스크/DB에서 읽은 데이터를 사용자 공간(User Space) 메모리로 가져와서, 애플리케이션(Java/Node)이 비즈니스 로직을 수행한 후 다시 네트워크로 보냅니다. CPU 사용량이 높습니다.

---

## 4. 스트리밍 서비스 원리 (Media Streaming)

### 📝 다운로드 vs 스트리밍 차이점
스포티파이나 유튜브 같은 서비스가 "다운로드 없이" 재생되는 원리는 **HTTP Range Request(범위 요청)**와 **Chunking(조각내기)** 기술에 있습니다.

#### 1) 일반 다운로드 (Download)
*   **방식**: 클라이언트가 파일을 요청하면 서버는 파일의 **처음부터 끝까지(0 ~ 100%)** 한번에 전송을 시작합니다.
*   **단점**: 1시간짜리 영화라면 파일 전체(예: 2GB)를 다 받아야만 끝부분을 볼 수 있습니다.

#### 2) 스트리밍 (Streaming)
*   **방식**: 파일을 잘게 쪼개서 필요한 만큼만 가져옵니다.
*   **핵심 기술: HTTP Range Header (RFC 7233)**
    *   클라이언트(브라우저): "이 영상의 **0바이트부터 100만바이트까지만** 주십시오." (`Range: bytes=0-1000000`)
    *   서버 (S3/웹서버): "부분 데이터 전송합니다." (`206 Partial Content`)
    *   사용자가 재생바(Seek Bar)를 중간으로 옮기면? -> 클라이언트가 해당 위치의 바이트 범위를 계산해서 다시 요청합니다 (`Range: bytes=5000000-6000000`).

### 🎬 고급 스트리밍 기술 (HLS / DASH)
단순 Range 요청을 넘어, 네트워크 상태에 따라 화질을 자동으로 조절하는 기술이 **Adaptive Bitrate Streaming**입니다.

1.  **인코딩**: 원본 영상을 여러 화질(1080p, 720p, 360p)로 미리 변환하고, 5초~10초 단위의 조각 파일(.ts) 수천 개로 분할합니다.
2.  **Manifest 파일 (.m3u8)**: "이 영상은 3가지 화질이 있고, 1번 조각은 여기, 2번 조각은 저기에 있습니다"라고 적힌 지도를 생성합니다.
3.  **재생**: 클라이언트가 네트워크가 빠르면 1080p 조각을 다운받고, 느려지면 360p 조각으로 변경합니다. (유튜브 화질이 자동으로 바뀌는 원리)

---

## 5. 정적 파일을 애플리케이션 서버에 저장할 위기 (Risks of Local Storage)
백엔드 서버(Spring Boot, Node.js 등) 내부 폴더(`src/resources` 등)에 사용자 업로드 파일을 저장할 경우 발생하는 결정적인 문제점들입니다.

### 🛑 1. Scale-out(서버 다중화) 불가능 (가장 큰 문제)
*   **시나리오**: 사용자가 많아져서 서버 1대(A)로는 부족해 서버 2대(A, B)를 띄우고 로드밸런서(L4)를 앞에 두었습니다.
*   **문제**:
    1.  사용자 '철수'가 자신의 프로필 사진을 업로드했습니다. 요청이 **A 서버**로 가서 A의 하드디스크에 사진이 저장됩니다.
    2.  나중에 '철수'가 프로필을 보려고 접속했습니다. 이번에는 로드밸런서가 '철수'를 **B 서버**로 보냅니다.
    3.  **B 서버**의 하드디스크에는 철수의 사진이 없습니다. -> **이미지 엑박(404 Not Found) 발생**.
*   **해결책**: 모든 서버가 공유하는 **공용 저장소(S3, NAS)**가 반드시 필요합니다.

### 💣 2. 배포 시 데이터 유실 (Ephemeral Filesystem)
*   **문제**: 현대적인 배포 방식(Docker, CI/CD)은 새로운 버전의 코드가 나오면 **기존 컨테이너(서버)를 삭제하고 새 컨테이너를 실행하는 방식**입니다.
*   **결과**: 사용자가 업로드한 사진들이 서버 배포(재시작) 시마다 모두 삭제됩니다.

### 🐌 3. 애플리케이션 성능 저하 (Thread Blocking)
*   **구조적 한계**: Spring Boot(Tomcat)나 Node.js는 기본적으로 **"비즈니스 로직(로그인, 결제, 계산)"**을 처리하기 위해 최적화되어 있습니다.
*   **문제**:
    *   사용자가 1GB짜리 대용량 영상을 다운로드하기 시작하면, 서버의 스레드(Thread) 하나가 그 작업을 유지해야 합니다.
    *   정적 파일 전송으로 인해 스레드가 점유되어, **로그인 요청을 처리할 스레드(Thread Pool)가 부족**해집니다.
    *   높은 비용의 리소스(WAS)를 단순 파일 전송에 사용하는 비효율이 발생합니다.

### 🔓 4. 보안 취약점 (Web Shell Upload)
*   **위험**: 사용자가 악의적으로 `hack.jsp`나 `hack.php` 같은 실행 가능한 스크립트 파일을 업로드합니다.
*   **공격**: 만약 서버가 이 파일을 "실행"하게 되면, 해커는 브라우저를 통해 서버의 모든 권한을 탈취할 수 있습니다(원격 명령 실행).
*   **방어**: S3 같은 스토리지 서비스는 파일을 "저장"만 하고 "실행" 기능 자체가 없어 원천적으로 안전합니다.

---

## 6. 공유 스토리지 아키텍처 (Shared Storage Architecture)
사용자가 "정적 파일을 공유 스토리지에 보관한다"는 개념을 정확히 이해하셨습니다. 이를 **Stateless Architecture**라고 부릅니다.

### 🏗️ 아키텍처 다이어그램 (개념도)
```mermaid
graph TD
    User[사용자 (Web/Mobile)]
    LB[로드밸런서 (Load Balancer)]
    
    subgraph "Backend Servers (Stateless Cluster)"
        Server1[Spring Boot Server A]
        Server2[Spring Boot Server B]
        Server3[Spring Boot Server C]
    end
    
    subgraph "Shared Storage (Stateful Layer)"
        DB[(Database - RDBMS)]
        S3[(AWS S3 - Object Storage)]
    end

    User --> LB
    LB --> Server1
    LB --> Server2
    LB --> Server3
    
    Server1 --> DB
    Server2 --> DB
    Server3 --> DB
    
    Server1 --> S3
    Server2 --> S3
    Server3 --> S3
```

### 🔑 핵심 원리
1.  **Backend Servers (Stateless)**: 서버 A, B, C는 서로 아무것도 공유하지 않습니다. 언제든지 삭제되거나 다시 생성되어도(Auto Scaling) 서비스에 문제가 없습니다. "로직(Logic)"만 있고 "데이터(Data)"는 없습니다.
2.  **Shared Storage (Stateful)**: 모든 "데이터"는 외부의 공유 저장소인 **DB(텍스트 데이터)**와 **S3(파일 데이터)**에만 저장합니다.
    *   서버 A가 S3에 파일을 쓰면(Write), 서버 C도 즉시 S3에서 그 파일을 읽을(Read) 수 있게 됩니다. 이것이 **데이터 일관성(Consistent)**을 보장하는 방법입니다.

---

## 7. 보안 및 성능 최적화: Presigned URL (Pre-signed URL)
초기에는 백엔드 서버가 파일을 받아서 S3로 넘겨주는 **Proxy 방식**을 사용했으나, 보안과 성능 이슈를 해결하기 위해 **Presigned URL 방식**으로 전환했습니다.

### 🚨 기존 방식의 문제점 (Proxy Upload)
1.  **보안 구멍**: S3 버킷에 데이터를 쓸 수 있는 권한을 가진 서버(IAM User)가 탈취당하면 버킷이 위험해집니다.
2.  **비효율적 경로**: `클라이언트 -> 서버(임시저장) -> S3`로 데이터가 두 번 이동합니다. (Double Hop)
3.  **서버 리소스 낭비**: 1GB 파일을 올릴 때 서버 메모리와 대역폭이 1GB만큼 소모됩니다.

### ✅ 해결 방법: Presigned URL (임시 서명된 URL)
AWS 보안 자격 증명을 가진 서버가 **"제한된 시간 동안, 이 파일명으로만 업로드할 수 있는 임시 티켓(URL)"**을 발급해주고, 클라이언트는 이 티켓으로 **S3에 직접 업로드**합니다.

#### 🏗️ 변경된 업로드 흐름 (Flow)
1.  **Request**: 클라이언트가 서버에게 "업로드 요청"을 보냅니다 (`POST /presigned-url`).
2.  **Sign**: 서버는 AWS SDK를 통해 서명된 URL을 생성합니다. (이때 DB 저장은 하지 않습니다).
3.  **Direct Upload**: 클라이언트는 받은 URL로 S3에 직접 `PUT` 요청을 보냅니다. (이때 헤더나 내용은 서버가 서명한 조건과 일치해야 합니다).
4.  **Confirm**: 업로드가 성공하면 클라이언트는 서버에게 "업로드 완료, DB에 저장 요청"을 보냅니다.

#### 🛡️ 보안 효과 (Security)
*   **Private Bucket**: S3 버킷을 **Public Write 금지(모든 퍼블릭 액세스 차단)**로 설정할 수 있습니다. 오직 서명된 URL을 가진 사용자만 쓸 수 있습니다.
*   **Time Limit**: URL은 10분 뒤에 만료되므로, URL이 유출되어도 해커가 악용할 시간이 제한적입니다.
*   **Condition**: 서버가 정한 파일명(`uuid_original.jpg`)과 Content-Type(`image/jpeg`)이 아니면 업로드가 거부됩니다.

---

## 8. S3 파일 접근 제어 (S3 Access Control: Referer & CORS)
S3 버킷을 단순히 퍼블릭으로 열어두면 URL이 유출되었을 때 누구나 파일을 다운로드해 갈 수 있고, 트래픽 비용이 과다 청구될 수 있습니다. 이를 방지하기 위해 **브라우저 기반의 접근 제어**를 구현했습니다.

### 🚨 문제 상황: 핫링크 (Hotlink) 및 무단 다운로드
*   **시나리오**: 누군가 우리 웹사이트의 이미지 URL(`https://s3.../image.jpg`)을 사용하여 자신의 블로그나 커뮤니티에 무단으로 게시합니다.
*   **피해**: 콘텐츠는 도용당하고, 트래픽 비용은 우리가 지불하게 됩니다.

### ✅ 해결 방법: Referer 검증 (Bucket Policy)
S3 버킷 정책(JSON)을 통해 **"요청의 출처(Referer)가 우리 웹사이트 도메인일 때만"** 파일을 제공하도록 설정했습니다.

#### 1) 핫링크 방지 원리
*   **정상 접속**: 사용자가 우리 웹사이트(`localhost:5173`)에서 이미지를 볼 때, 브라우저는 요청 헤더에 `Referer: http://localhost:5173/`을 포함하여 전송합니다. -> **S3: 허용 (200 OK)**
*   **불법 접속**: 사용자가 URL을 복사해서 새 탭에 붙여넣거나 메신저로 공유할 때, `Referer` 헤더가 없습니다. -> **S3: 차단 (403 Forbidden)**

#### 2) 적용된 버킷 정책 (JSON)
```json
"Condition": {
    "StringLike": {
        "aws:Referer": [
            "http://localhost:5173/*",
            "http://localhost:3000/*"
        ]
    }
}
```

### 🔐 CORS (Cross-Origin Resource Sharing)
Presigned URL 업로드를 위해 브라우저가 다른 도메인(S3)으로 `PUT` 요청을 보낼 수 있도록 CORS 정책도 함께 적용했습니다.
*   **허용 메서드**: `PUT`, `POST`, `GET`
*   **허용 헤더**: `*` (모든 헤더 허용)

---

### 📝 최종 요약 (기술 면접용)
> "본 프로젝트는 **Stateless 아키텍처**를 위해 S3를 파일 스토리지로 사용했습니다. 업로드 시에는 **Presigned URL**을 사용하여 백엔드 부하를 줄이고(S3 Direct Upload) 쓰기 권한을 제어했으며, 다운로드 시에는 **S3 Bucket Policy의 Referer 검증**을 통해 외부 사이트의 무단 링크(Hotlink)를 차단하고 자산을 보호했습니다."
